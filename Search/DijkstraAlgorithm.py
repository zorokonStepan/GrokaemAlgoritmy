"""
Алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно
добраться за минимальное время).
2. Обновить стоимости соседей этого узла
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь.

Алгоритм Дейкстры работает только с направленными ациклическими графами,
которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).

Алгоритм Дейкстры не может использоваться при наличии ребер, имеющих отрицательный вес

Чтобы найти кратчайший путь в графе, содержащем ребра с отрицательным весом
существует специальный алгоритм, называемый алгоритмом Беллмана-Форда.

Алгоритм Дейкстры реализуется с помощью 3х типов хеш-таблиц
хеш-таблица узлов
хеш-таблица стоимости
хеш-таблица родители

Пример:
        -> 6 -> A -> 1 ->
                ^
                |
start           3           end
                ^
                |
        -> 2 -> B -> 5 ->

"""

graph = dict()  # хеш-таблица узлов

graph["start"] = dict()
graph["start"]["a"] = 6
graph["start"]["b"] = 2

graph["a"] = dict()
graph["a"]["fin"] = 1
graph["b"] = dict()
graph["b"]["a"] = 3
graph["b"]["fin"] = 5
graph["fin"] = dict()  # У конечного узла нет соседей

# Код создания таблицы тоимостей costs:
infinity = float("inf")
costs = dict()
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity

# Код создания хеш-таблицы родителей:
parents = dict()
parents["a"] = "start"
parents["b"] = "start"
parents["in"] = None

# массив для отслеживания всех уже обработанных узлов, так как один узел не должен обрабатываться многократно
processed = []


def find_lowest_cost_node(costs):
    lowest_cost = float("inf")
    lowest_cost_node = None
    for node in costs:  # Перебрать все узлы
        cost = costs[node]
        # Если это узел с наименьшей стоимостью из уже виденных и он еще не был обработан
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost  # он назначается новым узлом с наименьшей стоимостью
            lowest_cost_node = node
    return lowest_cost_node


node = find_lowest_cost_node(costs)  # найти узел с наименьшей стоимостью среди необработанных
while node is not None:  # Если обработаны все узлы, цикл while завершен
    cost = costs[node]
    neighbors = graph[node]
    for n in neighbors.keys():  # перебрать всех соседей текущего узла
        new_cost = cost + neighbors[n]
        if costs[n] > new_cost:  # Если к соседу можно быстрее добраться через текущий узел
            costs[n] = new_cost  # то, обновить стоимость для этого узла
            parents[n] = node  # Этот узел становится новым родителем для соседа
    processed.append(node)  # Узел помечается как обработанный
    node = find_lowest_cost_node(costs)  # Найти следующий узел для обработки и повторить цикл
